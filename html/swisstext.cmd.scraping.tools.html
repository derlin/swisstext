
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Command line scraping tools &#8212; SwissText  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Searching commandline tool" href="swisstext.cmd.searching.html" />
    <link rel="prev" title="Scraping commandline tool" href="swisstext.cmd.scraping.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="swisstext.cmd.searching.html" title="Searching commandline tool"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="swisstext.cmd.scraping.html" title="Scraping commandline tool"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SwissText  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="apireference.html" >API Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="swisstext.cmd.html" >Commandline tools</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="swisstext.cmd.scraping.html" accesskey="U">Scraping commandline tool</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-swisstext.cmd.scraping.tools">
<span id="command-line-scraping-tools"></span><h1>Command line scraping tools<a class="headerlink" href="#module-swisstext.cmd.scraping.tools" title="Permalink to this headline">¶</a></h1>
<p>This package contains various implementations of the different pipeline tools.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="swisstext.cmd.scraping.html#module-swisstext.cmd.scraping.interfaces" title="swisstext.cmd.scraping.interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">interfaces</span></code></a></dt><dd><p>The tools interfaces definitions</p>
</dd>
<dt><a class="reference internal" href="swisstext.cmd.scraping.html#module-swisstext.cmd.scraping.config" title="swisstext.cmd.scraping.config"><code class="xref py py-mod docutils literal notranslate"><span class="pre">config</span></code></a></dt><dd><p>The default configuration instantiates tools from this package</p>
</dd>
</dl>
</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.basic_decider">
<span id="deciders"></span><h2>Deciders<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.basic_decider" title="Permalink to this headline">¶</a></h2>
<p>This module contains multiple <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.IDecider" title="swisstext.cmd.scraping.interfaces.IDecider"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDecider</span></code></a> implementations.</p>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.basic_decider.BasicDecider">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.basic_decider.</code><code class="descname">BasicDecider</code><span class="sig-paren">(</span><em>min_ratio=0</em>, <em>min_recrawl_delta: str = None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_decider.html#BasicDecider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.IDecider" title="swisstext.cmd.scraping.interfaces.IDecider"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.IDecider</span></code></a></p>
<p>A basic decider that:</p>
<ul>
<li><p>crawls URLs that fulfill one of the following criteria:</p>
<blockquote>
<div><ul class="simple">
<li><p>the URL is new,</p></li>
<li><p>the last visit yielded at least one new sentence on the last visit,</p></li>
<li><p>the last visit was older than <a class="reference internal" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_recrawl_delta" title="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_recrawl_delta"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min_recrawl_delta</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>blacklists URLs with no Swiss German sentences,</p></li>
<li><p>adds child URLs from a page only if the ratio between sentences and Swiss German sentences is greater or
equal <a class="reference internal" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_ratio" title="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_ratio"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min_ratio</span></code></a></p></li>
</ul>
<dl class="attribute">
<dt id="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_ratio">
<code class="descname">min_ratio</code><em class="property"> = None</em><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Child URLs are added only if sentence_count / sg_count &gt; min_ratio</p>
</dd></dl>

<dl class="attribute">
<dt id="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_recrawl_delta">
<code class="descname">min_recrawl_delta</code><em class="property"> = None</em><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_recrawl_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>a timedelta. URLs are revisited if now() - last visit &gt; min_recrawl_delta (UTC)</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.should_children_be_crawled">
<code class="descname">should_children_be_crawled</code><span class="sig-paren">(</span><em>page: swisstext.cmd.scraping.data.Page</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_decider.html#BasicDecider.should_children_be_crawled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.should_children_be_crawled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if
the page’s <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.data.Page.sg_count" title="swisstext.cmd.scraping.data.Page.sg_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sg_count</span></code></a> is above 0 and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sentence_count</span></code> /
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sg_count</span></code> &gt;= <a class="reference internal" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_ratio" title="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_ratio"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min_ratio</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.should_page_be_crawled">
<code class="descname">should_page_be_crawled</code><span class="sig-paren">(</span><em>page: swisstext.cmd.scraping.data.Page</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_decider.html#BasicDecider.should_page_be_crawled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.should_page_be_crawled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the URL is new,
the page’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">delta_count</span></code> above 0 or
the page’s <cite>:py:attr:~..data.Page.delta_date</cite> is older than <a class="reference internal" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_recrawl_delta" title="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.min_recrawl_delta"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min_recrawl_delta</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.basic_decider.BasicDecider.should_url_be_blacklisted">
<code class="descname">should_url_be_blacklisted</code><span class="sig-paren">(</span><em>page: swisstext.cmd.scraping.data.Page</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_decider.html#BasicDecider.should_url_be_blacklisted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider.should_url_be_blacklisted" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true only if the URL is new (first visit) and no Swiss German sentence is present in the page.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swisstext.cmd.scraping.tools.basic_decider.OnlyNewDecider">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.basic_decider.</code><code class="descname">OnlyNewDecider</code><span class="sig-paren">(</span><em>min_ratio=0</em>, <em>min_recrawl_delta: str = None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_decider.html#OnlyNewDecider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.OnlyNewDecider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider" title="swisstext.cmd.scraping.tools.basic_decider.BasicDecider"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.tools.basic_decider.BasicDecider</span></code></a></p>
<p>Same as <a class="reference internal" href="#swisstext.cmd.scraping.tools.basic_decider.BasicDecider" title="swisstext.cmd.scraping.tools.basic_decider.BasicDecider"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasicDecider</span></code></a>, but only crawls new URLs.</p>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.basic_decider.OnlyNewDecider.should_page_be_crawled">
<code class="descname">should_page_be_crawled</code><span class="sig-paren">(</span><em>page: swisstext.cmd.scraping.data.Page</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_decider.html#OnlyNewDecider.should_page_be_crawled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_decider.OnlyNewDecider.should_page_be_crawled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true only if the page is new.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.basic_seed_creator">
<span id="seed-creators"></span><h2>Seed Creators<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.basic_seed_creator" title="Permalink to this headline">¶</a></h2>
<p>This module contains multiple <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISeedCreator" title="swisstext.cmd.scraping.interfaces.ISeedCreator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ISeedCreator</span></code></a> implementations.
They all use sklearn vectorizers (word N-grams) under the hood.</p>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.BasicSeedCreator">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.basic_seed_creator.</code><code class="descname">BasicSeedCreator</code><span class="sig-paren">(</span><em>ngram_range=(3</em>, <em>3)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_seed_creator.html#BasicSeedCreator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.BasicSeedCreator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISeedCreator" title="swisstext.cmd.scraping.interfaces.ISeedCreator"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISeedCreator</span></code></a></p>
<p>A basic seed creator that uses an sklearn <code class="docutils literal notranslate"><span class="pre">CountVectorizer</span></code> to compute frequent word N-grams.
The generated seeds are simply the x most frequent N-grams found.</p>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.BasicSeedCreator.generate_seeds">
<code class="descname">generate_seeds</code><span class="sig-paren">(</span><em>sentences: List[str], max=10, stopwords: List[str] = None</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_seed_creator.html#BasicSeedCreator.generate_seeds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.BasicSeedCreator.generate_seeds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of seeds composed of the most frequent n-grams.</p>
</dd></dl>

<dl class="attribute">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.BasicSeedCreator.ngram_range">
<code class="descname">ngram_range</code><em class="property"> = None</em><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.BasicSeedCreator.ngram_range" title="Permalink to this definition">¶</a></dt>
<dd><p>ngram range parameter passed to the CountVectorizer</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.basic_seed_creator.</code><code class="descname">IdfSeedCreator</code><span class="sig-paren">(</span><em>sanitize=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_seed_creator.html#IdfSeedCreator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISeedCreator" title="swisstext.cmd.scraping.interfaces.ISeedCreator"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISeedCreator</span></code></a></p>
<p>A basic seed creator that uses an sklearn <code class="docutils literal notranslate"><span class="pre">TfidfVectorizer</span></code> to compute frequent word N-grams.
The generated seeds are the x n-grams with the highest score.</p>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator.generate_seeds">
<code class="descname">generate_seeds</code><span class="sig-paren">(</span><em>sentences: List[str], max=10, stopwords: List[str] = None</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/basic_seed_creator.html#IdfSeedCreator.generate_seeds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator.generate_seeds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of seeds composed of the most frequent n-grams (ponderated by IDF).</p>
</dd></dl>

<dl class="attribute">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator.kwargs">
<code class="descname">kwargs</code><em class="property"> = None</em><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator.kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>The arguments to pass to the vectorizer. They can be overriden in the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator.sanitize">
<code class="descname">sanitize</code><em class="property"> = None</em><a class="headerlink" href="#swisstext.cmd.scraping.tools.basic_seed_creator.IdfSeedCreator.sanitize" title="Permalink to this definition">¶</a></dt>
<dd><p>If this flag is set, digits that are not part of a word will be removed before feeding the 
vectorizer. This is useful because the <code class="docutils literal notranslate"><span class="pre">TfidfVectorizer</span></code>’s default token pattern considers
digits as actual words (but ignores punctuation, 
see <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/feature_extraction/text.py">the CountVectorizer token_pattern attribute</a>).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.bs_crawler">
<span id="crawlers"></span><h2>Crawlers<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.bs_crawler" title="Permalink to this headline">¶</a></h2>
<p>This module contains the implementation of a <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ICrawler" title="swisstext.cmd.scraping.interfaces.ICrawler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ICrawler</span></code></a>
that uses BeautifulSoup to extract text and links.</p>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.bs_crawler.</code><code class="descname">BsCrawler</code><span class="sig-paren">(</span><em>joiner=' '</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#BsCrawler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ICrawler" title="swisstext.cmd.scraping.interfaces.ICrawler"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ICrawler</span></code></a></p>
<p>A basic crawler implemented using <a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">BeautifulSoup</a>.</p>
<p>Text is extracted by concatenating all pieces of text (except CSS and script)
into one string using a space separator (no newlines).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This crawler implementation will return the page’s textual content in one bulk, with no newlines characters.
Consequently, results won’t be exploitable without a clever
<a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISplitter" title="swisstext.cmd.scraping.interfaces.ISplitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">ISplitter</span></code></a> (recall that the default implementation split text
based on newlines…) such as the <code class="xref py py-class docutils literal notranslate"><span class="pre">PunktSplitter</span></code>.</p>
</div>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.crawl">
<code class="descname">crawl</code><span class="sig-paren">(</span><em>url: str</em><span class="sig-paren">)</span> &#x2192; swisstext.cmd.scraping.interfaces.ICrawler.CrawlResults<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#BsCrawler.crawl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.crawl" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract links and text from a URL.</p>
</dd></dl>

<dl class="classmethod">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.extract_links">
<em class="property">classmethod </em><code class="descname">extract_links</code><span class="sig-paren">(</span><em>url</em>, <em>soup</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#BsCrawler.extract_links"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.extract_links" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all links from a soup (a href only).
Note that links will be resolved (relative to absolute) and filtered (non-HTML removed).</p>
</dd></dl>

<dl class="classmethod">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.extract_text_blocks">
<em class="property">classmethod </em><code class="descname">extract_text_blocks</code><span class="sig-paren">(</span><em>soup</em><span class="sig-paren">)</span> &#x2192; Generator[str, None, None]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#BsCrawler.extract_text_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.extract_text_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Get text blocks from a <code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> object.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is destructive, as it will first remove script, style and forms
from the HTML/soup object !</p>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="admonition-title">Todo</p>
<p>Find a way to avoid altering the soup object.. ?</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.get_soup">
<em class="property">classmethod </em><code class="descname">get_soup</code><span class="sig-paren">(</span><em>url</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#BsCrawler.get_soup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler.get_soup" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a <code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> object from a URL (HTML), dealing somewhat correctly with encoding.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.CleverBsCrawler">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.bs_crawler.</code><code class="descname">CleverBsCrawler</code><span class="sig-paren">(</span><em>joiner=' '</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#CleverBsCrawler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.CleverBsCrawler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler" title="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.tools.bs_crawler.BsCrawler</span></code></a></p>
<p>Another implementation of the <a class="reference internal" href="#swisstext.cmd.scraping.tools.bs_crawler.BsCrawler" title="swisstext.cmd.scraping.tools.bs_crawler.BsCrawler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsCrawler</span></code></a> that tries to be more clever during the text extraction
step.</p>
<p>Processing steps:</p>
<ol class="arabic simple">
<li><p>remove all scripts and CSS content (same as the BsCrawler)</p></li>
<li><p>try to detect the page’s main content using common naming schemes (<code class="docutils literal notranslate"><span class="pre">id=main</span></code>, <code class="docutils literal notranslate"><span class="pre">role=main</span></code>, etc).
If found, stop the processing and return only the text under it.</p></li>
<li><p>try to detect and remove the header, footer and navigation before returning the text</p></li>
</ol>
<p>Following those heuristics requires more processing power and might miss some sentences (full sentences
in the side bar, main content in a poorly-coded website, etc).</p>
<div class="admonition-todo admonition" id="index-1">
<p class="admonition-title">Todo</p>
<p>Make more thorough tests to determine if those heuristics are worth it. If so, make this implementation
the default.</p>
</div>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.CleverBsCrawler.extract_text_blocks">
<code class="descname">extract_text_blocks</code><span class="sig-paren">(</span><em>soup</em><span class="sig-paren">)</span> &#x2192; Generator[str, None, None]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/bs_crawler.html#CleverBsCrawler.extract_text_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.CleverBsCrawler.extract_text_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Get text blocks from a <code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> object.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is destructive, as it will first remove script, style and forms
from the HTML/soup object !</p>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="admonition-title">Todo</p>
<p>Find a way to avoid altering the soup object.. ?</p>
</div>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="swisstext.cmd.scraping.tools.bs_crawler.DEFAULT_HEADERS">
<code class="descclassname">swisstext.cmd.scraping.tools.bs_crawler.</code><code class="descname">DEFAULT_HEADERS</code><em class="property"> = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.89 Safari/537.36'}</em><a class="headerlink" href="#swisstext.cmd.scraping.tools.bs_crawler.DEFAULT_HEADERS" title="Permalink to this definition">¶</a></dt>
<dd><p>Headers passed with each request</p>
</dd></dl>

</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.console_saver">
<span id="savers"></span><h2>Savers<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.console_saver" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.console_saver.</code><code class="descname">ConsoleSaver</code><span class="sig-paren">(</span><em>sentences_file: str = None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISaver" title="swisstext.cmd.scraping.interfaces.ISaver"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISaver</span></code></a></p>
<p>Implementation of an <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISaver" title="swisstext.cmd.scraping.interfaces.ISaver"><code class="xref py py-class docutils literal notranslate"><span class="pre">ISaver</span></code></a> useful for testing and debugging.
It does not persist any results, but prints everything to the console instead.</p>
<p>Blacklisted URLs and sentences are kept in sets in memory.</p>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.blacklist_url">
<code class="descname">blacklist_url</code><span class="sig-paren">(</span><em>url: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.blacklist_url"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.blacklist_url" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Add the <cite>url</cite> to a blacklist.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.get_page">
<code class="descname">get_page</code><span class="sig-paren">(</span><em>url: str</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.get_page"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.get_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a page. The simplest implementation is just <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">Page(url)</span></code>.
If the subclass uses a data store, it should also populate the other page attributes (e.g. the score
information) so that the :py:class::<cite>IDecider</cite> can make clever decisions.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.is_url_blacklisted">
<code class="descname">is_url_blacklisted</code><span class="sig-paren">(</span><em>url: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.is_url_blacklisted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.is_url_blacklisted" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Tells if the given <cite>url</cite> is part of the blacklist. This is called at the beginning,
to avoid scraping pages unnecessarily.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.save_page">
<code class="descname">save_page</code><span class="sig-paren">(</span><em>page</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.save_page"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.save_page" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Persist a page.
This is called after the scraping, so all page’s attributes are set, including the
list of new :py:class::<cite>~swisstext.cmd.scraping.data.Sentence</cite> found.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.save_seed">
<code class="descname">save_seed</code><span class="sig-paren">(</span><em>seed: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.save_seed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.save_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Persist a seed (usually generated by the :py:class::<cite>ISeedGenerator</cite>).</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.sentence_exists">
<code class="descname">sentence_exists</code><span class="sig-paren">(</span><em>sentence: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/console_saver.html#ConsoleSaver.sentence_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.console_saver.ConsoleSaver.sentence_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Tells if the given Swiss German <cite>sentence</cite> already exists.
Only new sentences will be added to the page’s <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.data.Page.new_sg" title="swisstext.cmd.scraping.data.Page.new_sg"><code class="xref py py-attr docutils literal notranslate"><span class="pre">new_sg</span></code></a> attribute.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-swisstext.cmd.scraping.tools.mongo_saver"></span><dl class="class">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.mongo_saver.</code><code class="descname">MongoSaver</code><span class="sig-paren">(</span><em>db='st1'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISaver" title="swisstext.cmd.scraping.interfaces.ISaver"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISaver</span></code></a></p>
<p>This <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISaver" title="swisstext.cmd.scraping.interfaces.ISaver"><code class="xref py py-class docutils literal notranslate"><span class="pre">ISaver</span></code></a> implementation persists everything to
a MongoDB database.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="swisstext.mongo.html#module-swisstext.mongo" title="swisstext.mongo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">swisstext.mongo</span></code></a></dt><dd><p>Package defining the Mongo collections.</p>
</dd>
</dl>
</div>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.blacklist_url">
<code class="descname">blacklist_url</code><span class="sig-paren">(</span><em>url: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver.blacklist_url"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.blacklist_url" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Add the <cite>url</cite> to a blacklist.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.get_page">
<code class="descname">get_page</code><span class="sig-paren">(</span><em>url: str</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver.get_page"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.get_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a page. The simplest implementation is just <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">Page(url)</span></code>.
If the subclass uses a data store, it should also populate the other page attributes (e.g. the score
information) so that the :py:class::<cite>IDecider</cite> can make clever decisions.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.is_url_blacklisted">
<code class="descname">is_url_blacklisted</code><span class="sig-paren">(</span><em>url: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver.is_url_blacklisted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.is_url_blacklisted" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Tells if the given <cite>url</cite> is part of the blacklist. This is called at the beginning,
to avoid scraping pages unnecessarily.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.save_page">
<code class="descname">save_page</code><span class="sig-paren">(</span><em>page: swisstext.cmd.scraping.data.Page</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver.save_page"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.save_page" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Persist a page.
This is called after the scraping, so all page’s attributes are set, including the
list of new :py:class::<cite>~swisstext.cmd.scraping.data.Sentence</cite> found.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.save_seed">
<code class="descname">save_seed</code><span class="sig-paren">(</span><em>seed: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver.save_seed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.save_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Persist a seed (usually generated by the :py:class::<cite>ISeedGenerator</cite>).</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.sentence_exists">
<code class="descname">sentence_exists</code><span class="sig-paren">(</span><em>sentence: str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/mongo_saver.html#MongoSaver.sentence_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.mongo_saver.MongoSaver.sentence_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Tells if the given Swiss German <cite>sentence</cite> already exists.
Only new sentences will be added to the page’s <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.data.Page.new_sg" title="swisstext.cmd.scraping.data.Page.new_sg"><code class="xref py py-attr docutils literal notranslate"><span class="pre">new_sg</span></code></a> attribute.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.pattern_sentence_filter">
<span id="sentence-filters"></span><h2>Sentence Filters<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.pattern_sentence_filter" title="Permalink to this headline">¶</a></h2>
<p>This module contains an implementation of <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISentenceFilter" title="swisstext.cmd.scraping.interfaces.ISentenceFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">ISentenceFilter</span></code></a> that uses
simple rules to filter “well-formed” sentences.</p>
<div class="section" id="how-it-works">
<h3>How it works<a class="headerlink" href="#how-it-works" title="Permalink to this headline">¶</a></h3>
<p>Each sentence is checked against a list of rules and rejected / considered invalid if any of those rules fail.
Rules are thus <em>AND-based</em>.</p>
<dl class="simple">
<dt>Rules are defined using a simple YAML syntax and can be of two types: <em>length-based</em> (character count)</dt><dd><p>or <em>pattern-based</em> (regular expressions). They are checked in the same order they are defined.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Regular expressions can be quite expensive, so try to limit their complexity to the minimum required.</p></li>
<li><p>Rules are checked in the same order as they are defined, so it is advised to put the most generic / efficient
ones first.</p></li>
</ul>
</div>
</div>
<div class="section" id="rule-syntax">
<h3>Rule syntax<a class="headerlink" href="#rule-syntax" title="Permalink to this headline">¶</a></h3>
<p><strong>Length-based rules (length)</strong> must specify <em>at least one</em> of <em>min</em> or <em>max</em> length,
i.e. the bounds on the number of characters.
The rule succeeds if <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;=</span> <span class="pre">len(s)</span> <span class="pre">&lt;=</span> <span class="pre">max</span></code>. Here is an example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span> <span class="nt">max_length</span><span class="p">:</span>
  <span class="nt">descr</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">too long</span>
  <span class="nt">length</span><span class="p">:</span>
    <span class="nt">max</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1000</span>
</pre></div>
</div>
<p><strong>Pattern-based rules (find)</strong> a bit similarly, but instead of counting the number of characters, they count the number
of occurrences of a <em>pattern</em> (i.e. the number of matches when calling <code class="docutils literal notranslate"><span class="pre">re.findall(pattern,</span> <span class="pre">s)</span></code>).
The rule itself can be based on the raw count or based on a ratio:</p>
<ul class="simple">
<li><p>count: the rule succeeds if <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;=</span> <span class="pre">nb_matches</span> <span class="pre">&lt;=</span> <span class="pre">max</span></code></p></li>
<li><p>ratio: the rule succeeds if <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">&lt;=</span> <span class="pre">len(s)</span> <span class="pre">/</span> <span class="pre">(len(s)</span> <span class="pre">-</span> <span class="pre">nb_matches</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&lt;=</span> <span class="pre">max`</span></code></p></li>
</ul>
<p>Here are examples:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span> <span class="nt">min_words</span><span class="p">:</span>
  <span class="nt">descr</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">not enough words</span>
  <span class="nt">find</span><span class="p">:</span>
    <span class="nt">pattern</span><span class="p">:</span> <span class="s">&#39;\S+&#39;</span>
    <span class="nt">count</span><span class="p">:</span>
      <span class="nt">min</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">5</span>

<span class="p p-Indicator">-</span> <span class="nt">letters_proportional</span><span class="p">:</span>
  <span class="nt">descr</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">not enough letters proportion</span>
  <span class="nt">find</span><span class="p">:</span>
    <span class="nt">pattern</span><span class="p">:</span> <span class="s">&#39;[\W|\d]&#39;</span>
    <span class="nt">ratio</span><span class="p">:</span>
      <span class="nt">max</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.4</span>
</pre></div>
</div>
<p>Finally, <strong>an if condition</strong> can be used. If conditions are checked first, and if the check fails, the rule is
simply ignored:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span> <span class="nt">ellipsis</span><span class="p">:</span>
  <span class="nt">descr</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ellispsis on short sentences.</span>
  <span class="nt">if</span><span class="p">:</span>
    <span class="nt">length</span><span class="p">:</span>
      <span class="nt">max</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">30</span>
  <span class="nt">find</span><span class="p">:</span>
    <span class="nt">pattern</span><span class="p">:</span> <span class="s">&#39;(\.\s?){3}$&#39;</span>
    <span class="nt">count</span><span class="p">:</span>
      <span class="nt">max</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span>
</pre></div>
</div>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.pattern_sentence_filter.PatternSentenceFilter">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.pattern_sentence_filter.</code><code class="descname">PatternSentenceFilter</code><span class="sig-paren">(</span><em>rulespath=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/pattern_sentence_filter.html#PatternSentenceFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.pattern_sentence_filter.PatternSentenceFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISentenceFilter" title="swisstext.cmd.scraping.interfaces.ISentenceFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISentenceFilter</span></code></a></p>
<p>By default, rules are loaded from the default file <code class="docutils literal notranslate"><span class="pre">pattern_sentence_filter.yaml</span></code> in the current directory.
You can override this by passing a path to the constructor (<code class="docutils literal notranslate"><span class="pre">rulespath</span></code> argument).</p>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.pattern_sentence_filter.PatternSentenceFilter.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/pattern_sentence_filter.html#PatternSentenceFilter.is_valid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.pattern_sentence_filter.PatternSentenceFilter.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true only if all the rules were respected.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.punkt_splitter">
<span id="splitters"></span><h2>Splitters<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.punkt_splitter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.punkt_splitter.PunktSplitter">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.punkt_splitter.</code><code class="descname">PunktSplitter</code><span class="sig-paren">(</span><em>modelfile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/punkt_splitter.html#PunktSplitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.punkt_splitter.PunktSplitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISplitter" title="swisstext.cmd.scraping.interfaces.ISplitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISplitter</span></code></a></p>
<p>A splitter using the
<a class="reference external" href="https://www.nltk.org/api/nltk.tokenize.html#module-nltk.tokenize.punkt">PunktSentenceTokenizer</a>, the NLTK
implementation of the “Unsupervised Multilingual Sentence Boundary Detection (Kiss and Strunk (2005)” algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default implementation uses a model trained on English sentences.
<a class="reference external" href="https://www.kaggle.com/nltkdata/punkt/version/2#">This kaggle resource</a> offers
pretrained Punkt Models for other languages as well, including German. In my tests though, German models
performed poorly compared to the default…</p>
</div>
<div class="admonition-todo admonition" id="index-3">
<p class="admonition-title">Todo</p>
<p>Train a Punkt model for Swiss-German.
(<a class="reference external" href="https://stackoverflow.com/questions/21160310/training-data-format-for-nltk-punkt">https://stackoverflow.com/questions/21160310/training-data-format-for-nltk-punkt</a>)</p>
</div>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.punkt_splitter.PunktSplitter.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>text: str</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/punkt_splitter.html#PunktSplitter.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.punkt_splitter.PunktSplitter.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split text using Punkt.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-swisstext.cmd.scraping.tools.moses_splitter"></span><dl class="class">
<dt id="swisstext.cmd.scraping.tools.moses_splitter.MosesSplitter">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.moses_splitter.</code><code class="descname">MosesSplitter</code><span class="sig-paren">(</span><em>lang='de'</em>, <em>do_norm=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/moses_splitter.html#MosesSplitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.moses_splitter.MosesSplitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISplitter" title="swisstext.cmd.scraping.interfaces.ISplitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISplitter</span></code></a></p>
<p>A splitter using the Moses tool
<a class="reference external" href="https://github.com/moses-smt/mosesdecoder/blob/master/scripts/ems/support/split-sentences.perl">split_sentences.perl</a>.
The tool has been wrapped for use from Python, see <a class="reference external" href="https://pypi.org/project/mosestokenizer/">mosestokenizer</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The language option defines the non-breaking prefixes to use. Here, we use ‘de’ (German) by default.</p>
</div>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.moses_splitter.MosesSplitter.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>text: str</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/moses_splitter.html#MosesSplitter.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.moses_splitter.MosesSplitter.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split text using Moses.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-swisstext.cmd.scraping.tools.swigspot_langid">
<span id="language-detectors"></span><h2>Language Detectors<a class="headerlink" href="#module-swisstext.cmd.scraping.tools.swigspot_langid" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="swisstext.cmd.scraping.tools.swigspot_langid.SwigspotLangid">
<em class="property">class </em><code class="descclassname">swisstext.cmd.scraping.tools.swigspot_langid.</code><code class="descname">SwigspotLangid</code><a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/swigspot_langid.html#SwigspotLangid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.swigspot_langid.SwigspotLangid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="swisstext.cmd.scraping.html#swisstext.cmd.scraping.interfaces.ISgDetector" title="swisstext.cmd.scraping.interfaces.ISgDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">swisstext.cmd.scraping.interfaces.ISgDetector</span></code></a></p>
<p>This LID model was developed during the SwigSpot project.</p>
<p>In short, it uses 6000 character n-grams features (between 3 and 5 characters long) with TF-IDF scaling
and a logistic regression. Sentences are preprocessed by removing everything except letters, spaces, commas and dots.</p>
<p>All the details are available in the
<a class="reference external" href="https://github.com/derlin/SwigSpot_Schwyzertuutsch-Spotting">SwigSpot repository</a>.
The notebook for recreating the model is available <a class="reference external" href="https://github.com/derlin/SwigSpot_Schwyzertuutsch-Spotting/blob/master/language-detection/notebooks/09-FinalModel-SCRAPE.ipynb">here</a>.</p>
<dl class="method">
<dt id="swisstext.cmd.scraping.tools.swigspot_langid.SwigspotLangid.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>sentences: List[str]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/swigspot_langid.html#SwigspotLangid.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.swigspot_langid.SwigspotLangid.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>[ABSTRACT] Predict the Swiss German probability (between 0 and 1) of a list of sentences.</p>
</dd></dl>

<dl class="method">
<dt id="swisstext.cmd.scraping.tools.swigspot_langid.SwigspotLangid.sanitize">
<code class="descname">sanitize</code><span class="sig-paren">(</span><em>s: str</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/swisstext/cmd/scraping/tools/swigspot_langid.html#SwigspotLangid.sanitize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#swisstext.cmd.scraping.tools.swigspot_langid.SwigspotLangid.sanitize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Command line scraping tools</a><ul>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.basic_decider">Deciders</a></li>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.basic_seed_creator">Seed Creators</a></li>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.bs_crawler">Crawlers</a></li>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.console_saver">Savers</a></li>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.pattern_sentence_filter">Sentence Filters</a><ul>
<li><a class="reference internal" href="#how-it-works">How it works</a></li>
<li><a class="reference internal" href="#rule-syntax">Rule syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.punkt_splitter">Splitters</a></li>
<li><a class="reference internal" href="#module-swisstext.cmd.scraping.tools.swigspot_langid">Language Detectors</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="swisstext.cmd.scraping.html"
                        title="previous chapter">Scraping commandline tool</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="swisstext.cmd.searching.html"
                        title="next chapter">Searching commandline tool</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/swisstext.cmd.scraping.tools.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="swisstext.cmd.searching.html" title="Searching commandline tool"
             >next</a> |</li>
        <li class="right" >
          <a href="swisstext.cmd.scraping.html" title="Scraping commandline tool"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SwissText  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="apireference.html" >API Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="swisstext.cmd.html" >Commandline tools</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="swisstext.cmd.scraping.html" >Scraping commandline tool</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Lucy Linder.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>